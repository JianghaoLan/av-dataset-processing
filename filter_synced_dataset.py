import argparse


class SyncMeta:
    def __init__(self, id, vid, result_desp, best_offset, best_score, num_samples):  
        self.id = id
        self.vid = vid
        self.result_desp = result_desp
        self.best_offset = best_offset
        self.best_score = best_score
        self.num_samples = num_samples


def gen_sync_result(sync_result_list_path):
    with open(sync_result_list_path) as f:
        lines = f.readlines()
    for line in lines:
        data_path, result_desp, best_offset, best_score, num_samples = line.strip().split()
        id, vid = data_path.split('/')
        best_offset = int(best_offset)
        best_score = float(best_score)
        num_samples = int(num_samples)
        assert result_desp in ['no_enough_samples', 'low_score', 'success']
        yield SyncMeta(id, vid, result_desp, best_offset, best_score, num_samples)


def write_to_file(datas, file_path):
    with open(file_path, 'x') as f:
        f.writelines(map(lambda data: f'{data.id}/{data.vid}\n', datas))
    print(f'Saved to {file_path} .')


def filter_dataset(sync_result_list_path, score_thres, num_samples_thres, output_data_list_path, dry_run):
    datas = list(gen_sync_result(sync_result_list_path))
    ids = set(map(lambda data: data.id, datas))
    print('Sync result list path:', sync_result_list_path)
    print('Total synced video num:', len(datas))
    print('Total id num:', len(ids))
    
    success_datas = list(filter(lambda data: data.result_desp == 'success', datas))
    success_ids = set(map(lambda data: data.id, success_datas))
    print('Total successfully synced video num:', len(success_datas))
    print('Total successful id num:', len(success_ids))
    
    result_datas = []
    score_filtered_out_count = 0
    samples_filtered_out_count = 0
    for data in success_datas:
        if data.best_score < score_thres:
            score_filtered_out_count += 1
            continue
        if data.num_samples < num_samples_thres:
            samples_filtered_out_count += 1
            continue
        result_datas.append(data)
    result_ids = set(map(lambda data: data.id, result_datas))
    print('Total filtered synced video num:', len(result_datas))
    print('Total filtered id num:', len(result_ids))
    print('Videos filtered out because of low score:', score_filtered_out_count)
    print('Videos filtered out because of no enough samples:', samples_filtered_out_count)
    
    if not dry_run:
        result_datas.sort(key=lambda data: (data.id, data.vid))
        write_to_file(result_datas, output_data_list_path)


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument('--sync_result_list_path', type=str, required=True, help='root of result filelist generated by sync_dataset.py')
    parser.add_argument('--score_thres', type=float, default=-1, help='Score threshold')
    parser.add_argument('--num_samples_thres', type=float, default=-1, help='Samples number threshold')
    parser.add_argument('--output_data_list_path', type=str, default=None, help='Output data list path')
    parser.add_argument('--dry_run', action='store_true', help='Dry run this script without generate output file')
    args = parser.parse_args()
    
    sync_result_list_path = args.sync_result_list_path
    score_thres = args.score_thres
    num_samples_thres = args.num_samples_thres
    output_data_list_path = args.output_data_list_path
    dry_run = args.dry_run
    filter_dataset(sync_result_list_path, score_thres, num_samples_thres, output_data_list_path, dry_run)
    

if __name__ == '__main__':
    main()
